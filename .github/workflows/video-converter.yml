name: Temporary 16:9 -> 9:16 Converter

on:
  workflow_dispatch:
    inputs:
      keep_alive_minutes:
        description: "Keep the URL alive for N minutes"
        required: true
        default: "45"

jobs:
  serve:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install ffmpeg
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Flask
        run: |
          python -m pip install --upgrade pip
          pip install flask

      - name: Create app (upload -> ffmpeg -> download)
        run: |
          cat > app.py << 'PY'
          import os, subprocess, uuid
          from flask import Flask, request, send_file, abort

          app = Flask(__name__)
          AUTH_TOKEN = os.environ.get("AUTH_TOKEN", "")
          WORKDIR = os.environ.get("WORKDIR", "/tmp/work")
          os.makedirs(WORKDIR, exist_ok=True)

          HTML = """<!doctype html>
          <html>
            <head><meta charset="utf-8"><title>Video Converter</title></head>
            <body>
              <h3>16:9 â†’ 9:16 (center crop)</h3>
              <form action="/convert" method="post" enctype="multipart/form-data">
                <input type="password" name="token" placeholder="Token" required />
                <input type="file" name="video" accept="video/*" required />
                <button type="submit">Convert</button>
              </form>
            </body>
          </html>"""

          @app.get("/")
          def index():
            return HTML

          @app.post("/convert")
          def convert():
            token = request.form.get("token", "")
            if AUTH_TOKEN and token != AUTH_TOKEN:
              abort(401)

            f = request.files.get("video")
            if not f:
              abort(400, "No file uploaded")

            job = str(uuid.uuid4())
            in_path = os.path.join(WORKDIR, f"in_{job}.mp4")
            out_path = os.path.join(WORKDIR, f"out_{job}.mp4")
            f.save(in_path)

            cmd = [
              "ffmpeg", "-y",
              "-i", in_path,
              "-vf", "crop=ih*9/16:ih,scale=1080:1920",
              "-c:v", "libx264", "-preset", "veryfast", "-crf", "23",
              "-c:a", "aac", "-b:a", "128k",
              out_path
            ]
            subprocess.run(cmd, check=True)
            return send_file(out_path, as_attachment=True, download_name="converted_9x16.mp4")

          if __name__ == "__main__":
            app.run(host="0.0.0.0", port=8080)
          PY

      - name: Start server (background)
        env:
          AUTH_TOKEN: ${{ secrets.CONVERTER_TOKEN }}
          WORKDIR: /tmp/work
        run: |
          nohup python app.py > server.log 2>&1 &
          sleep 1
          curl -fsS http://127.0.0.1:8080/ >/dev/null

      - name: Download cloudflared
        run: |
          curl -L -o cloudflared https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
          chmod +x cloudflared
          ./cloudflared --version

      - name: Start Cloudflare Quick Tunnel + capture URL
        id: tunnel
        shell: bash
        run: |
          set -euo pipefail

          nohup ./cloudflared tunnel --url http://localhost:8080 > tunnel.log 2>&1 &

          # 1) Extract clean URL
          url=""
          for i in $(seq 1 60); do
            url="$(grep -oE 'https://[A-Za-z0-9.-]+\.trycloudflare\.com/?' tunnel.log | head -n 1 || true)"
            if [ -n "$url" ]; then
              break
            fi
            sleep 1
          done

          if [ -z "$url" ]; then
            echo "Failed to obtain trycloudflare.com URL. tunnel.log:" >&2
            tail -200 tunnel.log >&2
            exit 1
          fi

          # 2) Wait for DNS to resolve on the runner
          host="$(echo "$url" | sed -E 's#https?://##; s#/.*##')"
          echo "Waiting for DNS to resolve: $host"
          for i in $(seq 1 60); do
            if getent hosts "$host" >/dev/null 2>&1; then
              echo "DNS OK"
              break
            fi
            sleep 1
          done

          if ! getent hosts "$host" >/dev/null 2>&1; then
            echo "DNS still not resolving for $host" >&2
            tail -200 tunnel.log >&2
            exit 1
          fi

          echo "url=$url" >> "$GITHUB_OUTPUT"
          echo "Tunnel URL: $url"

      - name: Print URL
        run: |
          echo "Open this URL: ${{ steps.tunnel.outputs.url }}"
          echo "It will stay up for ~${{ inputs.keep_alive_minutes }} minutes."

      - name: Health check (via public URL)
        shell: bash
        run: |
          url='${{ steps.tunnel.outputs.url }}'
          # Extra safety in case anything adds formatting:
          clean="$(printf '%s' "$url" | grep -oE 'https://[A-Za-z0-9.-]+\.trycloudflare\.com/?' | head -n 1)"
          echo "Checking: $clean"
          curl -fsS --max-time 20 "$clean" >/dev/null
          echo "OK"


      - name: Keep alive
        run: |
          timeout ${{ inputs.keep_alive_minutes }}m sleep 7200
